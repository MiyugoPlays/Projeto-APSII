import aiomysql
from typing import List
from config import db_config
from user import User


class Administrator:
    def __init__(self, user: 'User'):
        self.user = user

    async def view_user(self, usr_id: int, db_config: dict) -> 'User':
        """View user by ID."""
        query = "SELECT * FROM users WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (usr_id,))
                    user_data = await cursor.fetchone()
                    return User(**user_data)

    async def suspend_user(self, usr_id: int, reason: str, db_config: dict) -> bool:
        """Suspend user."""
        query = "UPDATE users SET suspended = 1, suspension_reason = %s WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (reason, usr_id))
                    return True

    async def delete_user(self, usr_id: int, reason: str, db_config: dict) -> bool:
        """Delete user."""
        query = "DELETE FROM users WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (usr_id,))
                    return True

    async def search_user(self, usr_name: str) -> List['User']:
        """Search for users by name."""
        query = "SELECT * FROM users WHERE username LIKE %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (f"%{usr_name}%",))
                    users_data = await cursor.fetchall()
                    return [User(**user) for user in users_data]
import aiomysql
from typing import List
from config import db_config


class Booking:
    def __init__(self, id_booking: int, id_space: int, id_usr: int, start_date: str, end_date: str):
        self.id_booking = id_booking
        self.id_space = id_space
        self.id_usr = id_usr
        self.start_date = start_date
        self.end_date = end_date

    @staticmethod
    async def view_bookings(usr_id: int) -> List['Booking']:
        """View all bookings for a specific user."""
        query = "SELECT * FROM bookings WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (usr_id,))
                    bookings_data = await cursor.fetchall()
                    return [Booking(**booking) for booking in bookings_data]
import aiomysql
from typing import List
from config import db_config
from user import User
from space import Space
from review import Review
from booking import Booking


class Client:
    def __init__(self, user: 'User', description: str):
        self.user = user
        self.description = description
        self.spaces: List[Space] = []
        self.reviews: List[Review] = []
        self._insert()

    async def _insert(self) -> bool:
        """Insert client into the database."""
        query = "INSERT INTO clients (id_usr, description) VALUES (%s, %s);"
        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (self.user.id_usr, self.description))
                    return cursor.rowcount == 1
    async def create_space(self, space: 'Space') -> bool:
        self.spaces.append(space)
        await space.insert(db_config)
        return True

    async def change_description(self, new_description: str):
        self.description = new_description
        query = "UPDATE users SET description = %s WHERE id_usr = %s;"
        async with aiomysql.connect(**db_config) as conn:
            async with conn.cursor() as cursor:
                await cursor.execute(query, (new_description, self.user.id_usr))
                await conn.commit()

    async def view_bookings(self) -> List['Booking']:
        return await Booking.view_bookings(self.user.id_usr, db_config)

    async def add_review(self, review: 'Review') -> bool:
        self.reviews.append(review)
        await review.create_review(db_config)
        return True
db_config = {
    "host": "localhost",
    "port": 3306,                 # Modifique caso necessario
    "user": "user",      # MySQL user
    "password": "password",  # MySQL password
    "db": "nome_db",   # The name of the database you're using
    "autocommit": True,           # Optional: Auto-commit behavior
}
import aiomysql
from config import db_config


class Location:
    @staticmethod
    async def view_locals():
        query = "SELECT * FROM locations;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query)
                    locations = await cursor.fetchall()
                    return [Location(**loc) for loc in locations]

    @staticmethod
    async def get_location_by_id(id_local: int) -> 'Location':
        query = "SELECT * FROM locations WHERE id_local = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (id_local,))
                    location = await cursor.fetchone()
                    if location:
                        return Location(**location)
                    return None
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List
from user import User
from location import Location
from space import Space
from booking import Booking
from review import Review
from admin import Administrator
from config import db_config
from client import Client

app = FastAPI()


class UserCreateRequest(BaseModel):
    email: str
    password: str


class UserUpdateRequest(BaseModel):
    username: str


class LocationRequest(BaseModel):
    country: str
    country_code: str


class SpaceRequest(BaseModel):
    id_usr: int
    id_local: int
    price: float
    space_name: str
    space_desc: str
    space_photo: str
    rooms: int
    max_people: int
    area: float
    address: str
    latitude: float
    longitude: float


@app.post("/users/login")
async def login(user_request: UserCreateRequest):
    try:
        user = await User.login(user_request.email, user_request.password, db_config)
        return {"id_usr": user.id_usr, "username": user.username}
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid credentials")


@app.put("/users/{user_id}/username")
async def update_username(user_id: int, user_update: UserUpdateRequest):
    user = await User.view_user(user_id, db_config)
    if user:
        await user.change_username(user_update.username, db_config)
        return {"message": "Username updated successfully"}
    raise HTTPException(status_code=404, detail="User not found")


@app.post("/locations")
async def create_location(location_request: LocationRequest):
    location = Location(country=location_request.country, country_code=location_request.country_code)
    await location.insert(db_config)
    return {"message": "Location created successfully"}


@app.get("/locations/{location_id}")
async def get_location(location_id: int):
    location = await Location.get_location_by_id(location_id)
    if location:
        return location
    raise HTTPException(status_code=404, detail="Location not found")


@app.post("/spaces")
async def create_space(space_request: SpaceRequest):
    space = Space(
        id_usr=space_request.id_usr,
        id_local=space_request.id_local,
        price=space_request.price,
        space_name=space_request.space_name,
        space_desc=space_request.space_desc,
        space_photo=space_request.space_photo,
        rooms=space_request.rooms,
        max_people=space_request.max_people,
        area=space_request.area,
        address=space_request.address,
        latitude=space_request.latitude,
        longitude=space_request.longitude
    )
    await space.insert(db_config)
    return {"message": "Space created successfully"}


@app.get("/spaces/user/{user_id}")
async def get_spaces_by_user(user_id: int):
    spaces = await Space.view_spaces_by_user(user_id)
    return spaces


@app.get("/bookings/{user_id}")
async def get_bookings(user_id: int):
    bookings = await Booking.view_bookings(user_id)
    return bookings


@app.post("/clients/{user_id}/change-description")
async def change_client_description(user_id: int, description: str):
    user = await User.view_user(user_id, db_config)
    if user:
        client = Client(user=user, description=description)
        await client.change_description(description)
        return {"message": "Description updated"}
    raise HTTPException(status_code=404, detail="User not found")


@app.post("/administrator/suspend-user")
async def suspend_user(user_id: int, reason: str):
    admin = Administrator(user=await User.view_user(user_id, db_config))
    success = await admin.suspend_user(user_id, reason, db_config)
    if success:
        return {"message": "User suspended successfully"}
    raise HTTPException(status_code=400, detail="Error suspending user")


@app.post("/administrator/delete-user")
async def delete_user(user_id: int, reason: str):
    admin = Administrator(user=await User.view_user(user_id, db_config))
    success = await admin.delete_user(user_id, reason, db_config)
    if success:
        return {"message": "User deleted successfully"}
    raise HTTPException(status_code=400, detail="Error deleting user")


@app.get("/administrator/search-user/{username}")
async def search_user(username: str):
    admin = Administrator(user=None)
    users = await admin.search_user(username)
    return users
import aiomysql
from config import db_config


class Review:
    def __init__(self, review_text: str):
        self.review_text = review_text
        self.id_review = None
        self._insert()

    async def _insert(self) -> bool:
        query = """
        INSERT INTO reviews (review_text)
        VALUES (%s);
        """

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (self.review_text,))
                    if cursor.lastrowid:
                        self.id_review = cursor.lastrowid
                        return True
                    return False

    @staticmethod
    async def view_reviews() -> list:
        """Fetch all reviews from the database."""
        query = "SELECT * FROM reviews;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query)
                    reviews_data = await cursor.fetchall()
                    return reviews_data

    @staticmethod
    async def get_review_by_id(review_id: int) -> dict:
        """Fetch a review by its ID."""
        query = "SELECT * FROM reviews WHERE id_review = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (review_id,))
                    review = await cursor.fetchone()
                    return review if review else None
import aiomysql
from typing import List
from config import db_config


class Space:
    def __init__(self, id_space: int, id_usr: int, id_local: int, price: float, space_name: str, space_desc: str, space_photo: str, rooms: int, max_people: int, area: float, address: str, latitude: float, longitude: float):
        self.id_space = None
        self.id_usr = id_usr
        self.id_local = id_local
        self.price = price
        self.space_name = space_name
        self.space_desc = space_desc
        self.space_photo = space_photo
        self.rooms = rooms
        self.max_people = max_people
        self.area = area
        self.address = address
        self.latitude = latitude
        self.longitude = longitude
        self.reviews = []
        self._insert()

    async def _insert(self) -> bool:
        """Insert space into the database."""
        query = """
        INSERT INTO spaces (id_usr, id_local, price, space_name, space_desc, space_photo, rooms, max_people, area, address, latitude, longitude)
        VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s);
        """

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (self.id_usr, self.id_local, self.price, self.space_name, self.space_desc, self.space_photo, self.rooms, self.max_people, self.area, self.address, self.latitude, self.longitude))
                    if cursor.lastrowid:
                        self.id_space = cursor.lastrowid
                        return True
                    return False

    @staticmethod
    async def view_spaces_by_user(id_usr: int) -> List['Space']:
        """View all spaces by a specific user."""
        query = "SELECT * FROM spaces WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (id_usr,))
                    spaces_data = await cursor.fetchall()
                    return [Space(**space) for space in spaces_data]

    async def update_space(self) -> bool:
        """Update space information."""
        query = """
        UPDATE spaces
        SET price = %s, space_name = %s, space_desc = %s, space_photo = %s, rooms = %s, max_people = %s, area = %s, address = %s, latitude = %s, longitude = %s
        WHERE id_space = %s;
        """

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (self.price, self.space_name, self.space_desc, self.space_photo, self.rooms, self.max_people, self.area, self.address, self.latitude, self.longitude, self.id_space))
                    return True

    @staticmethod
    async def view_all_spaces() -> List['Space']:
        """View all spaces available in the database."""
        query = "SELECT * FROM spaces;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query)
                    spaces_data = await cursor.fetchall()
                    return [Space(**space) for space in spaces_data]
import aiomysql
from typing import Optional
from config import db_config


class User:
    def __init__(self, username: str, pfp: str, email: str, password: str, id_local: Optional[int] = None):
        self.username = username
        self.pfp = pfp
        self.email = email
        self.password = password
        self.id_local = id_local
        self.id_usr = None
        self._insert()

    async def _insert(self) -> bool:
        """Insert the user into the database."""
        query = """
        INSERT INTO users (username, pfp, email, password, id_local)
        VALUES (%s, %s, %s, %s, %s);
        """

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (self.username, self.pfp, self.email, self.password, self.id_local))
                    if cursor.lastrowid:
                        self.id_usr = cursor.lastrowid
                        return True
                    return False

    @staticmethod
    async def login(email: str, password: str) -> 'User':
        """Login using email and password."""
        query = "SELECT * FROM users WHERE email = %s AND password = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor(aiomysql.DictCursor) as cursor:
                    await cursor.execute(query, (email, password))
                    user_data = await cursor.fetchone()
                    if user_data:
                        return User(**user_data)
                    raise ValueError("Invalid credentials.")

    async def change_username(self, new_username: str) -> bool:
        """Change the username of the user."""
        self.username = new_username
        query = "UPDATE users SET username = %s WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (new_username, self.id_usr))
                    return True

    async def change_profile_picture(self, new_pfp: str) -> bool:
        """Change the profile picture of the user."""
        self.pfp = new_pfp
        query = "UPDATE users SET pfp = %s WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (new_pfp, self.id_usr))
                    return True

    async def change_password(self, old_pass: str, new_pass: str) -> bool:
        """Change the password of the user."""
        if self.password != old_pass:
            raise ValueError("Old password is incorrect.")

        self.password = new_pass
        query = "UPDATE users SET password = %s WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (new_pass, self.id_usr))
                    return True

    async def set_location(self, location: 'Location') -> bool:
        """Assign a location to the user."""
        self.id_local = location.id_local
        query = "UPDATE users SET id_local = %s WHERE id_usr = %s;"

        async with aiomysql.create_pool(**db_config) as pool:
            async with pool.acquire() as conn:
                async with conn.cursor() as cursor:
                    await cursor.execute(query, (location.id_local, self.id_usr))
                    return True
